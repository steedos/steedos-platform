{"version":3,"sources":["meteor://ðŸ’»app/packages/accounts-base/server_main.js","meteor://ðŸ’»app/packages/accounts-base/accounts_common.js","meteor://ðŸ’»app/packages/accounts-base/accounts_server.js"],"names":["module1","export","AccountsServer","link","v","Accounts","Meteor","server","users","_objectSpread","module","default","AccountsCommon","EXPIRE_TOKENS_INTERVAL_MS","CONNECTION_CLOSE_DELAY_MS","constructor","options","_options","connection","undefined","_initConnection","Mongo","Collection","_preventAutopublish","_onLoginHook","Hook","bindEnvironment","debugPrintExceptions","_onLoginFailureHook","_onLogoutHook","DEFAULT_LOGIN_EXPIRATION_DAYS","LOGIN_UNEXPIRING_TOKEN_DAYS","lceName","LoginCancelledError","makeErrorType","description","message","prototype","name","numericError","startup","ServiceConfiguration","Package","loginServiceConfiguration","configurations","ConfigError","userId","Error","user","findOne","config","isServer","__meteor_runtime_config__","accountsConfigCalled","_debug","Object","hasOwnProperty","call","isClient","OAuthEncryption","loadKey","oauthSecretKey","VALID_KEYS","keys","forEach","key","includes","onLogin","func","ret","register","_startupCallback","callback","onLoginFailure","onLogout","ddpUrl","DDP","connect","ACCOUNTS_CONNECTION_URL","_getTokenLifetimeMs","loginExpirationInDays","_getPasswordResetTokenLifetimeMs","passwordResetTokenExpirationInDays","DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS","_getPasswordEnrollTokenLifetimeMs","passwordEnrollTokenExpirationInDays","DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS","_tokenExpiration","when","Date","getTime","_tokenExpiresSoon","minLifetimeMs","minLifetimeCapMs","MIN_TOKEN_LIFETIME_CAP_SECS","_objectWithoutProperties","crypto","hasOwn","_server","_initServerMethods","_initAccountDataHooks","_autopublishFields","loggedInUser","otherUsers","_initServerPublications","_accountData","_userObservesForConnections","_nextUserObserveNumber","_loginHandlers","setupUsersCollection","setupDefaultLoginHandlers","setExpireTokensInterval","_validateLoginHook","_validateNewUserHooks","defaultValidateNewUserHook","bind","_deleteSavedTokensForAllUsersOnStartup","_skipCaseInsensitiveChecksForTest","urls","resetPassword","token","absoluteUrl","verifyEmail","enrollAccount","addDefaultRateLimit","currentInvocation","_CurrentMethodInvocation","get","_CurrentPublicationInvocation","validateLoginAttempt","validateNewUser","push","onCreateUser","_onCreateUserHook","onExternalLogin","_onExternalLoginHook","_validateLogin","attempt","each","cloneAttemptWithConnection","e","allowed","error","_successfulLogin","_failedLogin","_successfulLogout","_loginUser","methodInvocation","stampedLoginToken","_generateStampedLoginToken","_insertLoginToken","_noYieldsAllowed","_setLoginToken","_hashLoginToken","setUserId","id","tokenExpires","_attemptLogin","methodName","methodArgs","result","type","methodArguments","Array","from","_loginMethod","fn","tryLoginMethod","_reportLoginFailure","registerLoginHandler","handler","_runLoginHandlers","destroyToken","loginToken","update","$pull","$or","hashedToken","accounts","methods","login","check","arguments","logout","_getLoginToken","logoutOtherClients","fields","tokens","services","resume","loginTokens","newToken","$set","$push","_hashStampedToken","setTimeout","_deleteSavedTokensForUser","_noConnectionCloseDelayForTest","getNewToken","currentHashedToken","currentStampedToken","find","stampedToken","newStampedToken","removeOtherTokens","currentToken","$ne","configureLoginService","Match","ObjectIncluding","service","String","oauth","serviceNames","usingOAuthEncryption","secret","seal","insert","onConnection","onClose","_removeTokenFromConnection","publish","is_auto","_id","profile","username","emails","autopublish","toFieldSelector","reduce","prev","field","selector","addAutopublishFields","opts","apply","forLoggedInUser","forOtherUsers","_getAccountData","connectionId","data","_setAccountData","value","hash","createHash","digest","hashedStampedToken","_insertHashedLoginToken","query","$addToSet","_clearAllLoginTokens","_getUserObserve","observe","stop","myObserveNumber","defer","foundMatchingUser","observeChanges","added","removed","close","Random","_expirePasswordResetTokens","oldestValidDate","tokenLifetimeMs","tokenFilter","$exists","expirePasswordToken","_expirePasswordEnrollTokens","_expireTokens","userFilter","$lt","multi","superResult","expireTokenInterval","clearInterval","insertUserDoc","createdAt","pinEncryptedFieldsToUser","fullUser","defaultCreateUserHook","hook","errmsg","_testEmailDomain","email","domain","restrictCreationByEmailDomain","RegExp","_escapeRegExp","test","tokensToDelete","$unset","$pullAll","loginTokensToDelete","updateOrCreateUserFromExternalService","serviceName","serviceData","serviceIdKey","isNaN","parseInt","setAttrs","removeDefaultRateLimit","resp","DDPRateLimiter","removeRule","defaultRateLimiterRuleId","addRule","clientAddress","clonedAttempt","EJSON","clone","defaultResumeLoginHandler","oldUnhashedStyleToken","resetRangeOr","expireFilter","$and","setInterval","keyIsLoaded","isSealed","open","emailIsGood","length","address","values","allow","modifier","fetch","_ensureIndex","unique","sparse"],"mappings":"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","file":"/packages/accounts-base.js","sourcesContent":["import { AccountsServer } from \"./accounts_server.js\";\n\n/**\n * @namespace Accounts\n * @summary The namespace for all server-side accounts-related methods.\n */\nAccounts = new AccountsServer(Meteor.server);\n\n// Users table. Don't use the normal autopublish, since we want to hide\n// some fields. Code to autopublish this is in accounts_server.js.\n// XXX Allow users to configure this collection name.\n\n/**\n * @summary A [Mongo.Collection](#collections) containing user documents.\n * @locus Anywhere\n * @type {Mongo.Collection}\n * @importFromPackage meteor\n*/\nMeteor.users = Accounts.users;\n\nexport {\n  // Since this file is the main module for the server version of the\n  // accounts-base package, properties of non-entry-point modules need to\n  // be re-exported in order to be accessible to modules that import the\n  // accounts-base package.\n  AccountsServer\n};\n","/**\n * @summary Super-constructor for AccountsClient and AccountsServer.\n * @locus Anywhere\n * @class AccountsCommon\n * @instancename accountsClientOrServer\n * @param options {Object} an object with fields:\n * - connection {Object} Optional DDP connection to reuse.\n * - ddpUrl {String} Optional URL for creating a new DDP connection.\n */\nexport class AccountsCommon {\n  constructor(options) {\n    // Currently this is read directly by packages like accounts-password\n    // and accounts-ui-unstyled.\n    this._options = {};\n\n    // Note that setting this.connection = null causes this.users to be a\n    // LocalCollection, which is not what we want.\n    this.connection = undefined;\n    this._initConnection(options || {});\n\n    // There is an allow call in accounts_server.js that restricts writes to\n    // this collection.\n    this.users = new Mongo.Collection(\"users\", {\n      _preventAutopublish: true,\n      connection: this.connection\n    });\n\n    // Callback exceptions are printed with Meteor._debug and ignored.\n    this._onLoginHook = new Hook({\n      bindEnvironment: false,\n      debugPrintExceptions: \"onLogin callback\"\n    });\n\n    this._onLoginFailureHook = new Hook({\n      bindEnvironment: false,\n      debugPrintExceptions: \"onLoginFailure callback\"\n    });\n\n    this._onLogoutHook = new Hook({\n      bindEnvironment: false,\n      debugPrintExceptions: \"onLogout callback\"\n    });\n\n    // Expose for testing.\n    this.DEFAULT_LOGIN_EXPIRATION_DAYS = DEFAULT_LOGIN_EXPIRATION_DAYS;\n    this.LOGIN_UNEXPIRING_TOKEN_DAYS = LOGIN_UNEXPIRING_TOKEN_DAYS;\n\n    // Thrown when the user cancels the login process (eg, closes an oauth\n    // popup, declines retina scan, etc)\n    const lceName = 'Accounts.LoginCancelledError';\n    this.LoginCancelledError = Meteor.makeErrorType(\n      lceName,\n      function (description) {\n        this.message = description;\n      }\n    );\n    this.LoginCancelledError.prototype.name = lceName;\n\n    // This is used to transmit specific subclass errors over the wire. We\n    // should come up with a more generic way to do this (eg, with some sort of\n    // symbolic error code rather than a number).\n    this.LoginCancelledError.numericError = 0x8acdc2f;\n\n    // loginServiceConfiguration and ConfigError are maintained for backwards compatibility\n    Meteor.startup(() => {\n      const { ServiceConfiguration } = Package['service-configuration'];\n      this.loginServiceConfiguration = ServiceConfiguration.configurations;\n      this.ConfigError = ServiceConfiguration.ConfigError;\n    });\n  }\n\n  /**\n   * @summary Get the current user id, or `null` if no user is logged in. A reactive data source.\n   * @locus Anywhere\n   */\n  userId() {\n    throw new Error(\"userId method not implemented\");\n  }\n\n  /**\n   * @summary Get the current user record, or `null` if no user is logged in. A reactive data source.\n   * @locus Anywhere\n   */\n  user() {\n    const userId = this.userId();\n    return userId ? this.users.findOne(userId) : null;\n  }\n\n  // Set up config for the accounts system. Call this on both the client\n  // and the server.\n  //\n  // Note that this method gets overridden on AccountsServer.prototype, but\n  // the overriding method calls the overridden method.\n  //\n  // XXX we should add some enforcement that this is called on both the\n  // client and the server. Otherwise, a user can\n  // 'forbidClientAccountCreation' only on the client and while it looks\n  // like their app is secure, the server will still accept createUser\n  // calls. https://github.com/meteor/meteor/issues/828\n  //\n  // @param options {Object} an object with fields:\n  // - sendVerificationEmail {Boolean}\n  //     Send email address verification emails to new users created from\n  //     client signups.\n  // - forbidClientAccountCreation {Boolean}\n  //     Do not allow clients to create accounts directly.\n  // - restrictCreationByEmailDomain {Function or String}\n  //     Require created users to have an email matching the function or\n  //     having the string as domain.\n  // - loginExpirationInDays {Number}\n  //     Number of days since login until a user is logged out (login token\n  //     expires).\n  // - passwordResetTokenExpirationInDays {Number}\n  //     Number of days since password reset token creation until the\n  //     token cannt be used any longer (password reset token expires).\n  // - ambiguousErrorMessages {Boolean}\n  //     Return ambiguous error messages from login failures to prevent\n  //     user enumeration.\n  // - bcryptRounds {Number}\n  //     Allows override of number of bcrypt rounds (aka work factor) used\n  //     to store passwords.\n\n  /**\n   * @summary Set global accounts options.\n   * @locus Anywhere\n   * @param {Object} options\n   * @param {Boolean} options.sendVerificationEmail New users with an email address will receive an address verification email.\n   * @param {Boolean} options.forbidClientAccountCreation Calls to [`createUser`](#accounts_createuser) from the client will be rejected. In addition, if you are using [accounts-ui](#accountsui), the \"Create account\" link will not be available.\n   * @param {String | Function} options.restrictCreationByEmailDomain If set to a string, only allows new users if the domain part of their email address matches the string. If set to a function, only allows new users if the function returns true.  The function is passed the full email address of the proposed new user.  Works with password-based sign-in and external services that expose email addresses (Google, Facebook, GitHub). All existing users still can log in after enabling this option. Example: `Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })`.\n   * @param {Number} options.loginExpirationInDays The number of days from when a user logs in until their token expires and they are logged out. Defaults to 90. Set to `null` to disable login expiration.\n   * @param {String} options.oauthSecretKey When using the `oauth-encryption` package, the 16 byte key using to encrypt sensitive account credentials in the database, encoded in base64.  This option may only be specifed on the server.  See packages/oauth-encryption/README.md for details.\n   * @param {Number} options.passwordResetTokenExpirationInDays The number of days from when a link to reset password is sent until token expires and user can't reset password with the link anymore. Defaults to 3.\n   * @param {Number} options.passwordEnrollTokenExpirationInDays The number of days from when a link to set inital password is sent until token expires and user can't set password with the link anymore. Defaults to 30.\n   * @param {Boolean} options.ambiguousErrorMessages Return ambiguous error messages from login failures to prevent user enumeration. Defaults to false.\n   */\n  config(options) {\n    // We don't want users to accidentally only call Accounts.config on the\n    // client, where some of the options will have partial effects (eg removing\n    // the \"create account\" button from accounts-ui if forbidClientAccountCreation\n    // is set, or redirecting Google login to a specific-domain page) without\n    // having their full effects.\n    if (Meteor.isServer) {\n      __meteor_runtime_config__.accountsConfigCalled = true;\n    } else if (!__meteor_runtime_config__.accountsConfigCalled) {\n      // XXX would be nice to \"crash\" the client and replace the UI with an error\n      // message, but there's no trivial way to do this.\n      Meteor._debug(\"Accounts.config was called on the client but not on the \" +\n                    \"server; some configuration options may not take effect.\");\n    }\n\n    // We need to validate the oauthSecretKey option at the time\n    // Accounts.config is called. We also deliberately don't store the\n    // oauthSecretKey in Accounts._options.\n    if (Object.prototype.hasOwnProperty.call(options, 'oauthSecretKey')) {\n      if (Meteor.isClient) {\n        throw new Error(\"The oauthSecretKey option may only be specified on the server\");\n      }\n      if (! Package[\"oauth-encryption\"]) {\n        throw new Error(\"The oauth-encryption package must be loaded to set oauthSecretKey\");\n      }\n      Package[\"oauth-encryption\"].OAuthEncryption.loadKey(options.oauthSecretKey);\n      options = { ...options };\n      delete options.oauthSecretKey;\n    }\n\n    // validate option keys\n    const VALID_KEYS = [\"sendVerificationEmail\", \"forbidClientAccountCreation\", \"passwordEnrollTokenExpirationInDays\",\n                      \"restrictCreationByEmailDomain\", \"loginExpirationInDays\", \"passwordResetTokenExpirationInDays\",\n                      \"ambiguousErrorMessages\", \"bcryptRounds\"];\n    Object.keys(options).forEach(key => {\n      if (!VALID_KEYS.includes(key)) {\n        throw new Error(`Accounts.config: Invalid key: ${key}`);\n      }\n    });\n\n    // set values in Accounts._options\n    VALID_KEYS.forEach(key => {\n      if (key in options) {\n        if (key in this._options) {\n          throw new Error(`Can't set \\`${key}\\` more than once`);\n        }\n        this._options[key] = options[key];\n      }\n    });\n  }\n\n  /**\n   * @summary Register a callback to be called after a login attempt succeeds.\n   * @locus Anywhere\n   * @param {Function} func The callback to be called when login is successful.\n   *                        The callback receives a single object that\n   *                        holds login details. This object contains the login\n   *                        result type (password, resume, etc.) on both the\n   *                        client and server. `onLogin` callbacks registered\n   *                        on the server also receive extra data, such\n   *                        as user details, connection information, etc.\n   */\n  onLogin(func) {\n    let ret = this._onLoginHook.register(func);\n    // call the just registered callback if already logged in\n    this._startupCallback(ret.callback);\n    return ret;\n  }\n\n  /**\n   * @summary Register a callback to be called after a login attempt fails.\n   * @locus Anywhere\n   * @param {Function} func The callback to be called after the login has failed.\n   */\n  onLoginFailure(func) {\n    return this._onLoginFailureHook.register(func);\n  }\n\n  /**\n   * @summary Register a callback to be called after a logout attempt succeeds.\n   * @locus Anywhere\n   * @param {Function} func The callback to be called when logout is successful.\n   */\n  onLogout(func) {\n    return this._onLogoutHook.register(func);\n  }\n\n  _initConnection(options) {\n    if (! Meteor.isClient) {\n      return;\n    }\n\n    // The connection used by the Accounts system. This is the connection\n    // that will get logged in by Meteor.login(), and this is the\n    // connection whose login state will be reflected by Meteor.userId().\n    //\n    // It would be much preferable for this to be in accounts_client.js,\n    // but it has to be here because it's needed to create the\n    // Meteor.users collection.\n    if (options.connection) {\n      this.connection = options.connection;\n    } else if (options.ddpUrl) {\n      this.connection = DDP.connect(options.ddpUrl);\n    } else if (typeof __meteor_runtime_config__ !== \"undefined\" &&\n               __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL) {\n      // Temporary, internal hook to allow the server to point the client\n      // to a different authentication server. This is for a very\n      // particular use case that comes up when implementing a oauth\n      // server. Unsupported and may go away at any point in time.\n      //\n      // We will eventually provide a general way to use account-base\n      // against any DDP connection, not just one special one.\n      this.connection =\n        DDP.connect(__meteor_runtime_config__.ACCOUNTS_CONNECTION_URL);\n    } else {\n      this.connection = Meteor.connection;\n    }\n  }\n\n  _getTokenLifetimeMs() {\n    // When loginExpirationInDays is set to null, we'll use a really high\n    // number of days (LOGIN_UNEXPIRABLE_TOKEN_DAYS) to simulate an\n    // unexpiring token.\n    const loginExpirationInDays =\n      (this._options.loginExpirationInDays === null)\n        ? LOGIN_UNEXPIRING_TOKEN_DAYS\n        : this._options.loginExpirationInDays;\n    return (loginExpirationInDays\n        || DEFAULT_LOGIN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\n  }\n\n  _getPasswordResetTokenLifetimeMs() {\n    return (this._options.passwordResetTokenExpirationInDays ||\n            DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\n  }\n\n  _getPasswordEnrollTokenLifetimeMs() {\n    return (this._options.passwordEnrollTokenExpirationInDays ||\n        DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\n  }\n\n  _tokenExpiration(when) {\n    // We pass when through the Date constructor for backwards compatibility;\n    // `when` used to be a number.\n    return new Date((new Date(when)).getTime() + this._getTokenLifetimeMs());\n  }\n\n  _tokenExpiresSoon(when) {\n    let minLifetimeMs = .1 * this._getTokenLifetimeMs();\n    const minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\n    if (minLifetimeMs > minLifetimeCapMs) {\n      minLifetimeMs = minLifetimeCapMs;\n    }\n    return new Date() > (new Date(when) - minLifetimeMs);\n  }\n\n  // No-op on the server, overridden on the client.\n  _startupCallback(callback) {}\n}\n\n// Note that Accounts is defined separately in accounts_client.js and\n// accounts_server.js.\n\n/**\n * @summary Get the current user id, or `null` if no user is logged in. A reactive data source.\n * @locus Anywhere but publish functions\n * @importFromPackage meteor\n */\nMeteor.userId = () => Accounts.userId();\n\n/**\n * @summary Get the current user record, or `null` if no user is logged in. A reactive data source.\n * @locus Anywhere but publish functions\n * @importFromPackage meteor\n */\nMeteor.user = () => Accounts.user();\n\n// how long (in days) until a login token expires\nconst DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\n// how long (in days) until reset password token expires\nconst DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS = 3;\n// how long (in days) until enrol password token expires\nconst DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS = 30;\n// Clients don't try to auto-login with a token that is going to expire within\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\n// Tries to avoid abrupt disconnects from expiring tokens.\nconst MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\n// how often (in milliseconds) we check for expired tokens\nexport const EXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\n// how long we wait before logging out clients when Meteor.logoutOtherClients is\n// called\nexport const CONNECTION_CLOSE_DELAY_MS = 10 * 1000;\n// A large number of expiration days (approximately 100 years worth) that is\n// used when creating unexpiring tokens.\nconst LOGIN_UNEXPIRING_TOKEN_DAYS = 365 * 100;\n","import crypto from 'crypto';\nimport {\n  AccountsCommon,\n  EXPIRE_TOKENS_INTERVAL_MS,\n  CONNECTION_CLOSE_DELAY_MS\n} from './accounts_common.js';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n/**\n * @summary Constructor for the `Accounts` namespace on the server.\n * @locus Server\n * @class AccountsServer\n * @extends AccountsCommon\n * @instancename accountsServer\n * @param {Object} server A server object such as `Meteor.server`.\n */\nexport class AccountsServer extends AccountsCommon {\n  // Note that this constructor is less likely to be instantiated multiple\n  // times than the `AccountsClient` constructor, because a single server\n  // can provide only one set of methods.\n  constructor(server) {\n    super();\n\n    this._server = server || Meteor.server;\n    // Set up the server's methods, as if by calling Meteor.methods.\n    this._initServerMethods();\n\n    this._initAccountDataHooks();\n\n    // If autopublish is on, publish these user fields. Login service\n    // packages (eg accounts-google) add to these by calling\n    // addAutopublishFields.  Notably, this isn't implemented with multiple\n    // publishes since DDP only merges only across top-level fields, not\n    // subfields (such as 'services.facebook.accessToken')\n    this._autopublishFields = {\n      loggedInUser: ['profile', 'username', 'emails'],\n      otherUsers: ['profile', 'username']\n    };\n    this._initServerPublications();\n\n    // connectionId -> {connection, loginToken}\n    this._accountData = {};\n\n    // connection id -> observe handle for the login token that this connection is\n    // currently associated with, or a number. The number indicates that we are in\n    // the process of setting up the observe (using a number instead of a single\n    // sentinel allows multiple attempts to set up the observe to identify which\n    // one was theirs).\n    this._userObservesForConnections = {};\n    this._nextUserObserveNumber = 1;  // for the number described above.\n\n    // list of all registered handlers.\n    this._loginHandlers = [];\n\n    setupUsersCollection(this.users);\n    setupDefaultLoginHandlers(this);\n    setExpireTokensInterval(this);\n\n    this._validateLoginHook = new Hook({ bindEnvironment: false });\n    this._validateNewUserHooks = [\n      defaultValidateNewUserHook.bind(this)\n    ];\n\n    this._deleteSavedTokensForAllUsersOnStartup();\n\n    this._skipCaseInsensitiveChecksForTest = {};\n\n    // XXX These should probably not actually be public?\n    this.urls = {\n      resetPassword: token => Meteor.absoluteUrl(`#/reset-password/${token}`),\n      verifyEmail: token => Meteor.absoluteUrl(`#/verify-email/${token}`),\n      enrollAccount: token => Meteor.absoluteUrl(`#/enroll-account/${token}`),\n    }\n\n    this.addDefaultRateLimit()\n  }\n\n  ///\n  /// CURRENT USER\n  ///\n\n  // @override of \"abstract\" non-implementation in accounts_common.js\n  userId() {\n    // This function only works if called inside a method or a pubication.\n    // Using any of the infomation from Meteor.user() in a method or\n    // publish function will always use the value from when the function first\n    // runs. This is likely not what the user expects. The way to make this work\n    // in a method or publish function is to do Meteor.find(this.userId).observe\n    // and recompute when the user record changes.\n    const currentInvocation = DDP._CurrentMethodInvocation.get() || DDP._CurrentPublicationInvocation.get();\n    if (!currentInvocation)\n      throw new Error(\"Meteor.userId can only be invoked in method calls or publications.\");\n    return currentInvocation.userId;\n  }\n\n  ///\n  /// LOGIN HOOKS\n  ///\n\n  /**\n   * @summary Validate login attempts.\n   * @locus Server\n   * @param {Function} func Called whenever a login is attempted (either successful or unsuccessful).  A login can be aborted by returning a falsy value or throwing an exception.\n   */\n  validateLoginAttempt(func) {\n    // Exceptions inside the hook callback are passed up to us.\n    return this._validateLoginHook.register(func);\n  }\n\n  /**\n   * @summary Set restrictions on new user creation.\n   * @locus Server\n   * @param {Function} func Called whenever a new user is created. Takes the new user object, and returns true to allow the creation or false to abort.\n   */\n  validateNewUser(func) {\n    this._validateNewUserHooks.push(func);\n  }\n\n  ///\n  /// CREATE USER HOOKS\n  ///\n\n  /**\n   * @summary Customize new user creation.\n   * @locus Server\n   * @param {Function} func Called whenever a new user is created. Return the new user object, or throw an `Error` to abort the creation.\n   */\n  onCreateUser(func) {\n    if (this._onCreateUserHook) {\n      throw new Error(\"Can only call onCreateUser once\");\n    }\n\n    this._onCreateUserHook = func;\n  }\n\n  /**\n   * @summary Customize oauth user profile updates\n   * @locus Server\n   * @param {Function} func Called whenever a user is logged in via oauth. Return the profile object to be merged, or throw an `Error` to abort the creation.\n   */\n  onExternalLogin(func) {\n    if (this._onExternalLoginHook) {\n      throw new Error(\"Can only call onExternalLogin once\");\n    }\n\n    this._onExternalLoginHook = func;\n  }\n\n  _validateLogin(connection, attempt) {\n    this._validateLoginHook.each(callback => {\n      let ret;\n      try {\n        ret = callback(cloneAttemptWithConnection(connection, attempt));\n      }\n      catch (e) {\n        attempt.allowed = false;\n        // XXX this means the last thrown error overrides previous error\n        // messages. Maybe this is surprising to users and we should make\n        // overriding errors more explicit. (see\n        // https://github.com/meteor/meteor/issues/1960)\n        attempt.error = e;\n        return true;\n      }\n      if (! ret) {\n        attempt.allowed = false;\n        // don't override a specific error provided by a previous\n        // validator or the initial attempt (eg \"incorrect password\").\n        if (!attempt.error)\n          attempt.error = new Meteor.Error(403, \"Login forbidden\");\n      }\n      return true;\n    });\n  };\n\n  _successfulLogin(connection, attempt) {\n    this._onLoginHook.each(callback => {\n      callback(cloneAttemptWithConnection(connection, attempt));\n      return true;\n    });\n  };\n\n  _failedLogin(connection, attempt) {\n    this._onLoginFailureHook.each(callback => {\n      callback(cloneAttemptWithConnection(connection, attempt));\n      return true;\n    });\n  };\n\n  _successfulLogout(connection, userId) {\n    const user = userId && this.users.findOne(userId);\n    this._onLogoutHook.each(callback => {\n      callback({ user, connection });\n      return true;\n    });\n  };\n\n  ///\n  /// LOGIN METHODS\n  ///\n\n  // Login methods return to the client an object containing these\n  // fields when the user was logged in successfully:\n  //\n  //   id: userId\n  //   token: *\n  //   tokenExpires: *\n  //\n  // tokenExpires is optional and intends to provide a hint to the\n  // client as to when the token will expire. If not provided, the\n  // client will call Accounts._tokenExpiration, passing it the date\n  // that it received the token.\n  //\n  // The login method will throw an error back to the client if the user\n  // failed to log in.\n  //\n  //\n  // Login handlers and service specific login methods such as\n  // `createUser` internally return a `result` object containing these\n  // fields:\n  //\n  //   type:\n  //     optional string; the service name, overrides the handler\n  //     default if present.\n  //\n  //   error:\n  //     exception; if the user is not allowed to login, the reason why.\n  //\n  //   userId:\n  //     string; the user id of the user attempting to login (if\n  //     known), required for an allowed login.\n  //\n  //   options:\n  //     optional object merged into the result returned by the login\n  //     method; used by HAMK from SRP.\n  //\n  //   stampedLoginToken:\n  //     optional object with `token` and `when` indicating the login\n  //     token is already present in the database, returned by the\n  //     \"resume\" login handler.\n  //\n  // For convenience, login methods can also throw an exception, which\n  // is converted into an {error} result.  However, if the id of the\n  // user attempting the login is known, a {userId, error} result should\n  // be returned instead since the user id is not captured when an\n  // exception is thrown.\n  //\n  // This internal `result` object is automatically converted into the\n  // public {id, token, tokenExpires} object returned to the client.\n\n  // Try a login method, converting thrown exceptions into an {error}\n  // result.  The `type` argument is a default, inserted into the result\n  // object if not explicitly returned.\n  //\n  // Log in a user on a connection.\n  //\n  // We use the method invocation to set the user id on the connection,\n  // not the connection object directly. setUserId is tied to methods to\n  // enforce clear ordering of method application (using wait methods on\n  // the client, and a no setUserId after unblock restriction on the\n  // server)\n  //\n  // The `stampedLoginToken` parameter is optional.  When present, it\n  // indicates that the login token has already been inserted into the\n  // database and doesn't need to be inserted again.  (It's used by the\n  // \"resume\" login handler).\n  _loginUser(methodInvocation, userId, stampedLoginToken) {\n    if (! stampedLoginToken) {\n      stampedLoginToken = this._generateStampedLoginToken();\n      this._insertLoginToken(userId, stampedLoginToken);\n    }\n\n    // This order (and the avoidance of yields) is important to make\n    // sure that when publish functions are rerun, they see a\n    // consistent view of the world: the userId is set and matches\n    // the login token on the connection (not that there is\n    // currently a public API for reading the login token on a\n    // connection).\n    Meteor._noYieldsAllowed(() =>\n      this._setLoginToken(\n        userId,\n        methodInvocation.connection,\n        this._hashLoginToken(stampedLoginToken.token)\n      )\n    );\n\n    methodInvocation.setUserId(userId);\n\n    return {\n      id: userId,\n      token: stampedLoginToken.token,\n      tokenExpires: this._tokenExpiration(stampedLoginToken.when)\n    };\n  };\n\n  // After a login method has completed, call the login hooks.  Note\n  // that `attemptLogin` is called for *all* login attempts, even ones\n  // which aren't successful (such as an invalid password, etc).\n  //\n  // If the login is allowed and isn't aborted by a validate login hook\n  // callback, log in the user.\n  //\n  _attemptLogin(\n    methodInvocation,\n    methodName,\n    methodArgs,\n    result\n  ) {\n    if (!result)\n      throw new Error(\"result is required\");\n\n    // XXX A programming error in a login handler can lead to this occuring, and\n    // then we don't call onLogin or onLoginFailure callbacks. Should\n    // tryLoginMethod catch this case and turn it into an error?\n    if (!result.userId && !result.error)\n      throw new Error(\"A login method must specify a userId or an error\");\n\n    let user;\n    if (result.userId)\n      user = this.users.findOne(result.userId);\n\n    const attempt = {\n      type: result.type || \"unknown\",\n      allowed: !! (result.userId && !result.error),\n      methodName: methodName,\n      methodArguments: Array.from(methodArgs)\n    };\n    if (result.error) {\n      attempt.error = result.error;\n    }\n    if (user) {\n      attempt.user = user;\n    }\n\n    // _validateLogin may mutate `attempt` by adding an error and changing allowed\n    // to false, but that's the only change it can make (and the user's callbacks\n    // only get a clone of `attempt`).\n    this._validateLogin(methodInvocation.connection, attempt);\n\n    if (attempt.allowed) {\n      const ret = {\n        ...this._loginUser(\n          methodInvocation,\n          result.userId,\n          result.stampedLoginToken\n        ),\n        ...result.options\n      };\n      ret.type = attempt.type;\n      this._successfulLogin(methodInvocation.connection, attempt);\n      return ret;\n    }\n    else {\n      this._failedLogin(methodInvocation.connection, attempt);\n      throw attempt.error;\n    }\n  };\n\n  // All service specific login methods should go through this function.\n  // Ensure that thrown exceptions are caught and that login hook\n  // callbacks are still called.\n  //\n  _loginMethod(\n    methodInvocation,\n    methodName,\n    methodArgs,\n    type,\n    fn\n  ) {\n    return this._attemptLogin(\n      methodInvocation,\n      methodName,\n      methodArgs,\n      tryLoginMethod(type, fn)\n    );\n  };\n\n\n  // Report a login attempt failed outside the context of a normal login\n  // method. This is for use in the case where there is a multi-step login\n  // procedure (eg SRP based password login). If a method early in the\n  // chain fails, it should call this function to report a failure. There\n  // is no corresponding method for a successful login; methods that can\n  // succeed at logging a user in should always be actual login methods\n  // (using either Accounts._loginMethod or Accounts.registerLoginHandler).\n  _reportLoginFailure(\n    methodInvocation,\n    methodName,\n    methodArgs,\n    result\n  ) {\n    const attempt = {\n      type: result.type || \"unknown\",\n      allowed: false,\n      error: result.error,\n      methodName: methodName,\n      methodArguments: Array.from(methodArgs)\n    };\n\n    if (result.userId) {\n      attempt.user = this.users.findOne(result.userId);\n    }\n\n    this._validateLogin(methodInvocation.connection, attempt);\n    this._failedLogin(methodInvocation.connection, attempt);\n\n    // _validateLogin may mutate attempt to set a new error message. Return\n    // the modified version.\n    return attempt;\n  };\n\n  ///\n  /// LOGIN HANDLERS\n  ///\n\n  // The main entry point for auth packages to hook in to login.\n  //\n  // A login handler is a login method which can return `undefined` to\n  // indicate that the login request is not handled by this handler.\n  //\n  // @param name {String} Optional.  The service name, used by default\n  // if a specific service name isn't returned in the result.\n  //\n  // @param handler {Function} A function that receives an options object\n  // (as passed as an argument to the `login` method) and returns one of:\n  // - `undefined`, meaning don't handle;\n  // - a login method result object\n\n  registerLoginHandler(name, handler) {\n    if (! handler) {\n      handler = name;\n      name = null;\n    }\n\n    this._loginHandlers.push({\n      name: name,\n      handler: handler\n    });\n  };\n\n\n  // Checks a user's credentials against all the registered login\n  // handlers, and returns a login token if the credentials are valid. It\n  // is like the login method, except that it doesn't set the logged-in\n  // user on the connection. Throws a Meteor.Error if logging in fails,\n  // including the case where none of the login handlers handled the login\n  // request. Otherwise, returns {id: userId, token: *, tokenExpires: *}.\n  //\n  // For example, if you want to login with a plaintext password, `options` could be\n  //   { user: { username: <username> }, password: <password> }, or\n  //   { user: { email: <email> }, password: <password> }.\n\n  // Try all of the registered login handlers until one of them doesn't\n  // return `undefined`, meaning it handled this call to `login`. Return\n  // that return value.\n  _runLoginHandlers(methodInvocation, options) {\n    for (let handler of this._loginHandlers) {\n      const result = tryLoginMethod(\n        handler.name,\n        () => handler.handler.call(methodInvocation, options)\n      );\n\n      if (result) {\n        return result;\n      }\n\n      if (result !== undefined) {\n        throw new Meteor.Error(400, \"A login handler should return a result or undefined\");\n      }\n    }\n\n    return {\n      type: null,\n      error: new Meteor.Error(400, \"Unrecognized options for login request\")\n    };\n  };\n\n  // Deletes the given loginToken from the database.\n  //\n  // For new-style hashed token, this will cause all connections\n  // associated with the token to be closed.\n  //\n  // Any connections associated with old-style unhashed tokens will be\n  // in the process of becoming associated with hashed tokens and then\n  // they'll get closed.\n  destroyToken(userId, loginToken) {\n    this.users.update(userId, {\n      $pull: {\n        \"services.resume.loginTokens\": {\n          $or: [\n            { hashedToken: loginToken },\n            { token: loginToken }\n          ]\n        }\n      }\n    });\n  };\n\n  _initServerMethods() {\n    // The methods created in this function need to be created here so that\n    // this variable is available in their scope.\n    const accounts = this;\n\n\n    // This object will be populated with methods and then passed to\n    // accounts._server.methods further below.\n    const methods = {};\n\n    // @returns {Object|null}\n    //   If successful, returns {token: reconnectToken, id: userId}\n    //   If unsuccessful (for example, if the user closed the oauth login popup),\n    //     throws an error describing the reason\n    methods.login = function (options) {\n      // Login handlers should really also check whatever field they look at in\n      // options, but we don't enforce it.\n      check(options, Object);\n\n      const result = accounts._runLoginHandlers(this, options);\n\n      return accounts._attemptLogin(this, \"login\", arguments, result);\n    };\n\n    methods.logout = function () {\n      const token = accounts._getLoginToken(this.connection.id);\n      accounts._setLoginToken(this.userId, this.connection, null);\n      if (token && this.userId) {\n        accounts.destroyToken(this.userId, token);\n      }\n      accounts._successfulLogout(this.connection, this.userId);\n      this.setUserId(null);\n    };\n\n    // Delete all the current user's tokens and close all open connections logged\n    // in as this user. Returns a fresh new login token that this client can\n    // use. Tests set Accounts._noConnectionCloseDelayForTest to delete tokens\n    // immediately instead of using a delay.\n    //\n    // XXX COMPAT WITH 0.7.2\n    // This single `logoutOtherClients` method has been replaced with two\n    // methods, one that you call to get a new token, and another that you\n    // call to remove all tokens except your own. The new design allows\n    // clients to know when other clients have actually been logged\n    // out. (The `logoutOtherClients` method guarantees the caller that\n    // the other clients will be logged out at some point, but makes no\n    // guarantees about when.) This method is left in for backwards\n    // compatibility, especially since application code might be calling\n    // this method directly.\n    //\n    // @returns {Object} Object with token and tokenExpires keys.\n    methods.logoutOtherClients = function () {\n      const user = accounts.users.findOne(this.userId, {\n        fields: {\n          \"services.resume.loginTokens\": true\n        }\n      });\n      if (user) {\n        // Save the current tokens in the database to be deleted in\n        // CONNECTION_CLOSE_DELAY_MS ms. This gives other connections in the\n        // caller's browser time to find the fresh token in localStorage. We save\n        // the tokens in the database in case we crash before actually deleting\n        // them.\n        const tokens = user.services.resume.loginTokens;\n        const newToken = accounts._generateStampedLoginToken();\n        accounts.users.update(this.userId, {\n          $set: {\n            \"services.resume.loginTokensToDelete\": tokens,\n            \"services.resume.haveLoginTokensToDelete\": true\n          },\n          $push: { \"services.resume.loginTokens\": accounts._hashStampedToken(newToken) }\n        });\n        Meteor.setTimeout(() => {\n          // The observe on Meteor.users will take care of closing the connections\n          // associated with `tokens`.\n          accounts._deleteSavedTokensForUser(this.userId, tokens);\n        }, accounts._noConnectionCloseDelayForTest ? 0 :\n          CONNECTION_CLOSE_DELAY_MS);\n        // We do not set the login token on this connection, but instead the\n        // observe closes the connection and the client will reconnect with the\n        // new token.\n        return {\n          token: newToken.token,\n          tokenExpires: accounts._tokenExpiration(newToken.when)\n        };\n      } else {\n        throw new Meteor.Error(\"You are not logged in.\");\n      }\n    };\n\n    // Generates a new login token with the same expiration as the\n    // connection's current token and saves it to the database. Associates\n    // the connection with this new token and returns it. Throws an error\n    // if called on a connection that isn't logged in.\n    //\n    // @returns Object\n    //   If successful, returns { token: <new token>, id: <user id>,\n    //   tokenExpires: <expiration date> }.\n    methods.getNewToken = function () {\n      const user = accounts.users.findOne(this.userId, {\n        fields: { \"services.resume.loginTokens\": 1 }\n      });\n      if (! this.userId || ! user) {\n        throw new Meteor.Error(\"You are not logged in.\");\n      }\n      // Be careful not to generate a new token that has a later\n      // expiration than the curren token. Otherwise, a bad guy with a\n      // stolen token could use this method to stop his stolen token from\n      // ever expiring.\n      const currentHashedToken = accounts._getLoginToken(this.connection.id);\n      const currentStampedToken = user.services.resume.loginTokens.find(\n        stampedToken => stampedToken.hashedToken === currentHashedToken\n      );\n      if (! currentStampedToken) { // safety belt: this should never happen\n        throw new Meteor.Error(\"Invalid login token\");\n      }\n      const newStampedToken = accounts._generateStampedLoginToken();\n      newStampedToken.when = currentStampedToken.when;\n      accounts._insertLoginToken(this.userId, newStampedToken);\n      return accounts._loginUser(this, this.userId, newStampedToken);\n    };\n\n    // Removes all tokens except the token associated with the current\n    // connection. Throws an error if the connection is not logged\n    // in. Returns nothing on success.\n    methods.removeOtherTokens = function () {\n      if (! this.userId) {\n        throw new Meteor.Error(\"You are not logged in.\");\n      }\n      const currentToken = accounts._getLoginToken(this.connection.id);\n      accounts.users.update(this.userId, {\n        $pull: {\n          \"services.resume.loginTokens\": { hashedToken: { $ne: currentToken } }\n        }\n      });\n    };\n\n    // Allow a one-time configuration for a login service. Modifications\n    // to this collection are also allowed in insecure mode.\n    methods.configureLoginService = (options) => {\n      check(options, Match.ObjectIncluding({service: String}));\n      // Don't let random users configure a service we haven't added yet (so\n      // that when we do later add it, it's set up with their configuration\n      // instead of ours).\n      // XXX if service configuration is oauth-specific then this code should\n      //     be in accounts-oauth; if it's not then the registry should be\n      //     in this package\n      if (!(accounts.oauth\n        && accounts.oauth.serviceNames().includes(options.service))) {\n        throw new Meteor.Error(403, \"Service unknown\");\n      }\n\n      const { ServiceConfiguration } = Package['service-configuration'];\n      if (ServiceConfiguration.configurations.findOne({service: options.service}))\n        throw new Meteor.Error(403, `Service ${options.service} already configured`);\n\n      if (hasOwn.call(options, 'secret') && usingOAuthEncryption())\n        options.secret = OAuthEncryption.seal(options.secret);\n\n      ServiceConfiguration.configurations.insert(options);\n    };\n\n    accounts._server.methods(methods);\n  };\n\n  _initAccountDataHooks() {\n    this._server.onConnection(connection => {\n      this._accountData[connection.id] = {\n        connection: connection\n      };\n\n      connection.onClose(() => {\n        this._removeTokenFromConnection(connection.id);\n        delete this._accountData[connection.id];\n      });\n    });\n  };\n\n  _initServerPublications() {\n    // Bring into lexical scope for publish callbacks that need `this`\n    const { users, _autopublishFields } = this;\n\n    // Publish all login service configuration fields other than secret.\n    this._server.publish(\"meteor.loginServiceConfiguration\", () => {\n      const { ServiceConfiguration } = Package['service-configuration'];\n      return ServiceConfiguration.configurations.find({}, {fields: {secret: 0}});\n    }, {is_auto: true}); // not techincally autopublish, but stops the warning.\n\n    // Publish the current user's record to the client.\n    this._server.publish(null, function () {\n      if (this.userId) {\n        return users.find({\n          _id: this.userId\n        }, {\n          fields: {\n            profile: 1,\n            username: 1,\n            emails: 1\n          }\n        });\n      } else {\n        return null;\n      }\n    }, /*suppress autopublish warning*/{is_auto: true});\n\n    // Use Meteor.startup to give other packages a chance to call\n    // addAutopublishFields.\n    Package.autopublish && Meteor.startup(() => {\n      // ['profile', 'username'] -> {profile: 1, username: 1}\n      const toFieldSelector = fields => fields.reduce((prev, field) => (\n          { ...prev, [field]: 1 }),\n        {}\n      );\n      this._server.publish(null, function () {\n        if (this.userId) {\n          return users.find({ _id: this.userId }, {\n            fields: toFieldSelector(_autopublishFields.loggedInUser),\n          })\n        } else {\n          return null;\n        }\n      }, /*suppress autopublish warning*/{is_auto: true});\n\n      // XXX this publish is neither dedup-able nor is it optimized by our special\n      // treatment of queries on a specific _id. Therefore this will have O(n^2)\n      // run-time performance every time a user document is changed (eg someone\n      // logging in). If this is a problem, we can instead write a manual publish\n      // function which filters out fields based on 'this.userId'.\n      this._server.publish(null, function () {\n        const selector = this.userId ? { _id: { $ne: this.userId } } : {};\n        return users.find(selector, {\n          fields: toFieldSelector(_autopublishFields.otherUsers),\n        })\n      }, /*suppress autopublish warning*/{is_auto: true});\n    });\n  };\n\n  // Add to the list of fields or subfields to be automatically\n  // published if autopublish is on. Must be called from top-level\n  // code (ie, before Meteor.startup hooks run).\n  //\n  // @param opts {Object} with:\n  //   - forLoggedInUser {Array} Array of fields published to the logged-in user\n  //   - forOtherUsers {Array} Array of fields published to users that aren't logged in\n  addAutopublishFields(opts) {\n    this._autopublishFields.loggedInUser.push.apply(\n      this._autopublishFields.loggedInUser, opts.forLoggedInUser);\n    this._autopublishFields.otherUsers.push.apply(\n      this._autopublishFields.otherUsers, opts.forOtherUsers);\n  };\n\n  ///\n  /// ACCOUNT DATA\n  ///\n\n  // HACK: This is used by 'meteor-accounts' to get the loginToken for a\n  // connection. Maybe there should be a public way to do that.\n  _getAccountData(connectionId, field) {\n    const data = this._accountData[connectionId];\n    return data && data[field];\n  };\n\n  _setAccountData(connectionId, field, value) {\n    const data = this._accountData[connectionId];\n\n    // safety belt. shouldn't happen. accountData is set in onConnection,\n    // we don't have a connectionId until it is set.\n    if (!data)\n      return;\n\n    if (value === undefined)\n      delete data[field];\n    else\n      data[field] = value;\n  };\n\n  ///\n  /// RECONNECT TOKENS\n  ///\n  /// support reconnecting using a meteor login token\n\n  _hashLoginToken(loginToken) {\n    const hash = crypto.createHash('sha256');\n    hash.update(loginToken);\n    return hash.digest('base64');\n  };\n\n  // {token, when} => {hashedToken, when}\n  _hashStampedToken(stampedToken) {\n    const { token, ...hashedStampedToken } = stampedToken;\n    return {\n      ...hashedStampedToken,\n      hashedToken: this._hashLoginToken(token)\n    };\n  };\n\n  // Using $addToSet avoids getting an index error if another client\n  // logging in simultaneously has already inserted the new hashed\n  // token.\n  _insertHashedLoginToken(userId, hashedToken, query) {\n    query = query ? { ...query } : {};\n    query._id = userId;\n    this.users.update(query, {\n      $addToSet: {\n        \"services.resume.loginTokens\": hashedToken\n      }\n    });\n  };\n\n  // Exported for tests.\n  _insertLoginToken(userId, stampedToken, query) {\n    this._insertHashedLoginToken(\n      userId,\n      this._hashStampedToken(stampedToken),\n      query\n    );\n  };\n\n  _clearAllLoginTokens(userId) {\n    this.users.update(userId, {\n      $set: {\n        'services.resume.loginTokens': []\n      }\n    });\n  };\n\n  // test hook\n  _getUserObserve(connectionId) {\n    return this._userObservesForConnections[connectionId];\n  };\n\n  // Clean up this connection's association with the token: that is, stop\n  // the observe that we started when we associated the connection with\n  // this token.\n  _removeTokenFromConnection(connectionId) {\n    if (hasOwn.call(this._userObservesForConnections, connectionId)) {\n      const observe = this._userObservesForConnections[connectionId];\n      if (typeof observe === 'number') {\n        // We're in the process of setting up an observe for this connection. We\n        // can't clean up that observe yet, but if we delete the placeholder for\n        // this connection, then the observe will get cleaned up as soon as it has\n        // been set up.\n        delete this._userObservesForConnections[connectionId];\n      } else {\n        delete this._userObservesForConnections[connectionId];\n        observe.stop();\n      }\n    }\n  };\n\n  _getLoginToken(connectionId) {\n    return this._getAccountData(connectionId, 'loginToken');\n  };\n\n  // newToken is a hashed token.\n  _setLoginToken(userId, connection, newToken) {\n    this._removeTokenFromConnection(connection.id);\n    this._setAccountData(connection.id, 'loginToken', newToken);\n\n    if (newToken) {\n      // Set up an observe for this token. If the token goes away, we need\n      // to close the connection.  We defer the observe because there's\n      // no need for it to be on the critical path for login; we just need\n      // to ensure that the connection will get closed at some point if\n      // the token gets deleted.\n      //\n      // Initially, we set the observe for this connection to a number; this\n      // signifies to other code (which might run while we yield) that we are in\n      // the process of setting up an observe for this connection. Once the\n      // observe is ready to go, we replace the number with the real observe\n      // handle (unless the placeholder has been deleted or replaced by a\n      // different placehold number, signifying that the connection was closed\n      // already -- in this case we just clean up the observe that we started).\n      const myObserveNumber = ++this._nextUserObserveNumber;\n      this._userObservesForConnections[connection.id] = myObserveNumber;\n      Meteor.defer(() => {\n        // If something else happened on this connection in the meantime (it got\n        // closed, or another call to _setLoginToken happened), just do\n        // nothing. We don't need to start an observe for an old connection or old\n        // token.\n        if (this._userObservesForConnections[connection.id] !== myObserveNumber) {\n          return;\n        }\n\n        let foundMatchingUser;\n        // Because we upgrade unhashed login tokens to hashed tokens at\n        // login time, sessions will only be logged in with a hashed\n        // token. Thus we only need to observe hashed tokens here.\n        const observe = this.users.find({\n          _id: userId,\n          'services.resume.loginTokens.hashedToken': newToken\n        }, { fields: { _id: 1 } }).observeChanges({\n          added: () => {\n            foundMatchingUser = true;\n          },\n          removed: connection.close,\n          // The onClose callback for the connection takes care of\n          // cleaning up the observe handle and any other state we have\n          // lying around.\n        });\n\n        // If the user ran another login or logout command we were waiting for the\n        // defer or added to fire (ie, another call to _setLoginToken occurred),\n        // then we let the later one win (start an observe, etc) and just stop our\n        // observe now.\n        //\n        // Similarly, if the connection was already closed, then the onClose\n        // callback would have called _removeTokenFromConnection and there won't\n        // be an entry in _userObservesForConnections. We can stop the observe.\n        if (this._userObservesForConnections[connection.id] !== myObserveNumber) {\n          observe.stop();\n          return;\n        }\n\n        this._userObservesForConnections[connection.id] = observe;\n\n        if (! foundMatchingUser) {\n          // We've set up an observe on the user associated with `newToken`,\n          // so if the new token is removed from the database, we'll close\n          // the connection. But the token might have already been deleted\n          // before we set up the observe, which wouldn't have closed the\n          // connection because the observe wasn't running yet.\n          connection.close();\n        }\n      });\n    }\n  };\n\n  // (Also used by Meteor Accounts server and tests).\n  //\n  _generateStampedLoginToken() {\n    return {\n      token: Random.secret(),\n      when: new Date\n    };\n  };\n\n  ///\n  /// TOKEN EXPIRATION\n  ///\n\n  // Deletes expired password reset tokens from the database.\n  //\n  // Exported for tests. Also, the arguments are only used by\n  // tests. oldestValidDate is simulate expiring tokens without waiting\n  // for them to actually expire. userId is used by tests to only expire\n  // tokens for the test user.\n  _expirePasswordResetTokens(oldestValidDate, userId) {\n    const tokenLifetimeMs = this._getPasswordResetTokenLifetimeMs();\n\n    // when calling from a test with extra arguments, you must specify both!\n    if ((oldestValidDate && !userId) || (!oldestValidDate && userId)) {\n      throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\n    }\n\n    oldestValidDate = oldestValidDate ||\n      (new Date(new Date() - tokenLifetimeMs));\n\n    const tokenFilter = {\n      $or: [\n        { \"services.password.reset.reason\": \"reset\"},\n        { \"services.password.reset.reason\": {$exists: false}}\n      ]\n    };\n\n    expirePasswordToken(this, oldestValidDate, tokenFilter, userId);\n  }\n\n  // Deletes expired password enroll tokens from the database.\n  //\n  // Exported for tests. Also, the arguments are only used by\n  // tests. oldestValidDate is simulate expiring tokens without waiting\n  // for them to actually expire. userId is used by tests to only expire\n  // tokens for the test user.\n  _expirePasswordEnrollTokens(oldestValidDate, userId) {\n    const tokenLifetimeMs = this._getPasswordEnrollTokenLifetimeMs();\n\n    // when calling from a test with extra arguments, you must specify both!\n    if ((oldestValidDate && !userId) || (!oldestValidDate && userId)) {\n      throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\n    }\n\n    oldestValidDate = oldestValidDate ||\n      (new Date(new Date() - tokenLifetimeMs));\n\n    const tokenFilter = {\n      \"services.password.reset.reason\": \"enroll\"\n    };\n\n    expirePasswordToken(this, oldestValidDate, tokenFilter, userId);\n  }\n\n  // Deletes expired tokens from the database and closes all open connections\n  // associated with these tokens.\n  //\n  // Exported for tests. Also, the arguments are only used by\n  // tests. oldestValidDate is simulate expiring tokens without waiting\n  // for them to actually expire. userId is used by tests to only expire\n  // tokens for the test user.\n  _expireTokens(oldestValidDate, userId) {\n    const tokenLifetimeMs = this._getTokenLifetimeMs();\n\n    // when calling from a test with extra arguments, you must specify both!\n    if ((oldestValidDate && !userId) || (!oldestValidDate && userId)) {\n      throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\n    }\n\n    oldestValidDate = oldestValidDate ||\n      (new Date(new Date() - tokenLifetimeMs));\n    const userFilter = userId ? {_id: userId} : {};\n\n\n    // Backwards compatible with older versions of meteor that stored login token\n    // timestamps as numbers.\n    this.users.update({ ...userFilter,\n      $or: [\n        { \"services.resume.loginTokens.when\": { $lt: oldestValidDate } },\n        { \"services.resume.loginTokens.when\": { $lt: +oldestValidDate } }\n      ]\n    }, {\n      $pull: {\n        \"services.resume.loginTokens\": {\n          $or: [\n            { when: { $lt: oldestValidDate } },\n            { when: { $lt: +oldestValidDate } }\n          ]\n        }\n      }\n    }, { multi: true });\n    // The observe on Meteor.users will take care of closing connections for\n    // expired tokens.\n  };\n\n  // @override from accounts_common.js\n  config(options) {\n    // Call the overridden implementation of the method.\n    const superResult = AccountsCommon.prototype.config.apply(this, arguments);\n\n    // If the user set loginExpirationInDays to null, then we need to clear the\n    // timer that periodically expires tokens.\n    if (hasOwn.call(this._options, 'loginExpirationInDays') &&\n      this._options.loginExpirationInDays === null &&\n      this.expireTokenInterval) {\n      Meteor.clearInterval(this.expireTokenInterval);\n      this.expireTokenInterval = null;\n    }\n\n    return superResult;\n  };\n\n  // Called by accounts-password\n  insertUserDoc(options, user) {\n    // - clone user document, to protect from modification\n    // - add createdAt timestamp\n    // - prepare an _id, so that you can modify other collections (eg\n    // create a first task for every new user)\n    //\n    // XXX If the onCreateUser or validateNewUser hooks fail, we might\n    // end up having modified some other collection\n    // inappropriately. The solution is probably to have onCreateUser\n    // accept two callbacks - one that gets called before inserting\n    // the user document (in which you can modify its contents), and\n    // one that gets called after (in which you should change other\n    // collections)\n    user = {\n      createdAt: new Date(),\n      _id: Random.id(),\n      ...user,\n    };\n\n    if (user.services) {\n      Object.keys(user.services).forEach(service =>\n        pinEncryptedFieldsToUser(user.services[service], user._id)\n      );\n    }\n\n    let fullUser;\n    if (this._onCreateUserHook) {\n      fullUser = this._onCreateUserHook(options, user);\n\n      // This is *not* part of the API. We need this because we can't isolate\n      // the global server environment between tests, meaning we can't test\n      // both having a create user hook set and not having one set.\n      if (fullUser === 'TEST DEFAULT HOOK')\n        fullUser = defaultCreateUserHook(options, user);\n    } else {\n      fullUser = defaultCreateUserHook(options, user);\n    }\n\n    this._validateNewUserHooks.forEach(hook => {\n      if (! hook(fullUser))\n        throw new Meteor.Error(403, \"User validation failed\");\n    });\n\n    let userId;\n    try {\n      userId = this.users.insert(fullUser);\n    } catch (e) {\n      // XXX string parsing sucks, maybe\n      // https://jira.mongodb.org/browse/SERVER-3069 will get fixed one day\n      if (!e.errmsg) throw e;\n      if (e.errmsg.includes('emails.address'))\n        throw new Meteor.Error(403, \"Email already exists.\");\n      if (e.errmsg.includes('username'))\n        throw new Meteor.Error(403, \"Username already exists.\");\n      throw e;\n    }\n    return userId;\n  };\n\n  // Helper function: returns false if email does not match company domain from\n  // the configuration.\n  _testEmailDomain(email) {\n    const domain = this._options.restrictCreationByEmailDomain;\n\n    return !domain ||\n      (typeof domain === 'function' && domain(email)) ||\n      (typeof domain === 'string' &&\n        (new RegExp(`@${Meteor._escapeRegExp(domain)}$`, 'i')).test(email));\n  };\n\n  ///\n  /// CLEAN UP FOR `logoutOtherClients`\n  ///\n\n  _deleteSavedTokensForUser(userId, tokensToDelete) {\n    if (tokensToDelete) {\n      this.users.update(userId, {\n        $unset: {\n          \"services.resume.haveLoginTokensToDelete\": 1,\n          \"services.resume.loginTokensToDelete\": 1\n        },\n        $pullAll: {\n          \"services.resume.loginTokens\": tokensToDelete\n        }\n      });\n    }\n  };\n\n  _deleteSavedTokensForAllUsersOnStartup() {\n    // If we find users who have saved tokens to delete on startup, delete\n    // them now. It's possible that the server could have crashed and come\n    // back up before new tokens are found in localStorage, but this\n    // shouldn't happen very often. We shouldn't put a delay here because\n    // that would give a lot of power to an attacker with a stolen login\n    // token and the ability to crash the server.\n    Meteor.startup(() => {\n      this.users.find({\n        \"services.resume.haveLoginTokensToDelete\": true\n      }, {\n        \"services.resume.loginTokensToDelete\": 1\n      }).forEach(user => {\n        this._deleteSavedTokensForUser(\n          user._id,\n          user.services.resume.loginTokensToDelete\n        );\n      });\n    });\n  };\n\n  ///\n  /// MANAGING USER OBJECTS\n  ///\n\n  // Updates or creates a user after we authenticate with a 3rd party.\n  //\n  // @param serviceName {String} Service name (eg, twitter).\n  // @param serviceData {Object} Data to store in the user's record\n  //        under services[serviceName]. Must include an \"id\" field\n  //        which is a unique identifier for the user in the service.\n  // @param options {Object, optional} Other options to pass to insertUserDoc\n  //        (eg, profile)\n  // @returns {Object} Object with token and id keys, like the result\n  //        of the \"login\" method.\n  //\n  updateOrCreateUserFromExternalService(\n    serviceName,\n    serviceData,\n    options\n  ) {\n    options = { ...options };\n\n    if (serviceName === \"password\" || serviceName === \"resume\") {\n      throw new Error(\n        \"Can't use updateOrCreateUserFromExternalService with internal service \"\n        + serviceName);\n    }\n    if (!hasOwn.call(serviceData, 'id')) {\n      throw new Error(\n        `Service data for service ${serviceName} must include id`);\n    }\n\n    // Look for a user with the appropriate service user id.\n    const selector = {};\n    const serviceIdKey = `services.${serviceName}.id`;\n\n    // XXX Temporary special case for Twitter. (Issue #629)\n    //   The serviceData.id will be a string representation of an integer.\n    //   We want it to match either a stored string or int representation.\n    //   This is to cater to earlier versions of Meteor storing twitter\n    //   user IDs in number form, and recent versions storing them as strings.\n    //   This can be removed once migration technology is in place, and twitter\n    //   users stored with integer IDs have been migrated to string IDs.\n    if (serviceName === \"twitter\" && !isNaN(serviceData.id)) {\n      selector[\"$or\"] = [{},{}];\n      selector[\"$or\"][0][serviceIdKey] = serviceData.id;\n      selector[\"$or\"][1][serviceIdKey] = parseInt(serviceData.id, 10);\n    } else {\n      selector[serviceIdKey] = serviceData.id;\n    }\n\n    let user = this.users.findOne(selector);\n\n    // When creating a new user we pass through all options. When updating an\n    // existing user, by default we only process/pass through the serviceData\n    // (eg, so that we keep an unexpired access token and don't cache old email\n    // addresses in serviceData.email). The onExternalLogin hook can be used when\n    // creating or updating a user, to modify or pass through more options as\n    // needed.\n    let opts = user ? {} : options;\n    if (this._onExternalLoginHook) {\n      opts = this._onExternalLoginHook(options, user);\n    }\n\n    if (user) {\n      pinEncryptedFieldsToUser(serviceData, user._id);\n\n      let setAttrs = {};\n      Object.keys(serviceData).forEach(key =>\n        setAttrs[`services.${serviceName}.${key}`] = serviceData[key]\n      );\n\n      // XXX Maybe we should re-use the selector above and notice if the update\n      //     touches nothing?\n      setAttrs = { ...setAttrs, ...opts };\n      this.users.update(user._id, {\n        $set: setAttrs\n      });\n\n      return {\n        type: serviceName,\n        userId: user._id\n      };\n    } else {\n      // Create a new user with the service data.\n      user = {services: {}};\n      user.services[serviceName] = serviceData;\n      return {\n        type: serviceName,\n        userId: this.insertUserDoc(opts, user)\n      };\n    }\n  };\n\n  // Removes default rate limiting rule\n  removeDefaultRateLimit() {\n    const resp = DDPRateLimiter.removeRule(this.defaultRateLimiterRuleId);\n    this.defaultRateLimiterRuleId = null;\n    return resp;\n  };\n\n  // Add a default rule of limiting logins, creating new users and password reset\n  // to 5 times every 10 seconds per connection.\n  addDefaultRateLimit() {\n    if (!this.defaultRateLimiterRuleId) {\n      this.defaultRateLimiterRuleId = DDPRateLimiter.addRule({\n        userId: null,\n        clientAddress: null,\n        type: 'method',\n        name: name => ['login', 'createUser', 'resetPassword', 'forgotPassword']\n          .includes(name),\n        connectionId: (connectionId) => true,\n      }, 5, 10000);\n    }\n  };\n\n}\n\n// Give each login hook callback a fresh cloned copy of the attempt\n// object, but don't clone the connection.\n//\nconst cloneAttemptWithConnection = (connection, attempt) => {\n  const clonedAttempt = EJSON.clone(attempt);\n  clonedAttempt.connection = connection;\n  return clonedAttempt;\n};\n\nconst tryLoginMethod = (type, fn) => {\n  let result;\n  try {\n    result = fn();\n  }\n  catch (e) {\n    result = {error: e};\n  }\n\n  if (result && !result.type && type)\n    result.type = type;\n\n  return result;\n};\n\nconst setupDefaultLoginHandlers = accounts => {\n  accounts.registerLoginHandler(\"resume\", function (options) {\n    return defaultResumeLoginHandler.call(this, accounts, options);\n  });\n};\n\n// Login handler for resume tokens.\nconst defaultResumeLoginHandler = (accounts, options) => {\n  if (!options.resume)\n    return undefined;\n\n  check(options.resume, String);\n\n  const hashedToken = accounts._hashLoginToken(options.resume);\n\n  // First look for just the new-style hashed login token, to avoid\n  // sending the unhashed token to the database in a query if we don't\n  // need to.\n  let user = accounts.users.findOne(\n    {\"services.resume.loginTokens.hashedToken\": hashedToken});\n\n  if (! user) {\n    // If we didn't find the hashed login token, try also looking for\n    // the old-style unhashed token.  But we need to look for either\n    // the old-style token OR the new-style token, because another\n    // client connection logging in simultaneously might have already\n    // converted the token.\n    user = accounts.users.findOne({\n      $or: [\n        {\"services.resume.loginTokens.hashedToken\": hashedToken},\n        {\"services.resume.loginTokens.token\": options.resume}\n      ]\n    });\n  }\n\n  if (! user)\n    return {\n      error: new Meteor.Error(403, \"You've been logged out by the server. Please log in again.\")\n    };\n\n  // Find the token, which will either be an object with fields\n  // {hashedToken, when} for a hashed token or {token, when} for an\n  // unhashed token.\n  let oldUnhashedStyleToken;\n  let token = user.services.resume.loginTokens.find(token =>\n    token.hashedToken === hashedToken\n  );\n  if (token) {\n    oldUnhashedStyleToken = false;\n  } else {\n    token = user.services.resume.loginTokens.find(token =>\n      token.token === options.resume\n    );\n    oldUnhashedStyleToken = true;\n  }\n\n  const tokenExpires = accounts._tokenExpiration(token.when);\n  if (new Date() >= tokenExpires)\n    return {\n      userId: user._id,\n      error: new Meteor.Error(403, \"Your session has expired. Please log in again.\")\n    };\n\n  // Update to a hashed token when an unhashed token is encountered.\n  if (oldUnhashedStyleToken) {\n    // Only add the new hashed token if the old unhashed token still\n    // exists (this avoids resurrecting the token if it was deleted\n    // after we read it).  Using $addToSet avoids getting an index\n    // error if another client logging in simultaneously has already\n    // inserted the new hashed token.\n    accounts.users.update(\n      {\n        _id: user._id,\n        \"services.resume.loginTokens.token\": options.resume\n      },\n      {$addToSet: {\n          \"services.resume.loginTokens\": {\n            \"hashedToken\": hashedToken,\n            \"when\": token.when\n          }\n        }}\n    );\n\n    // Remove the old token *after* adding the new, since otherwise\n    // another client trying to login between our removing the old and\n    // adding the new wouldn't find a token to login with.\n    accounts.users.update(user._id, {\n      $pull: {\n        \"services.resume.loginTokens\": { \"token\": options.resume }\n      }\n    });\n  }\n\n  return {\n    userId: user._id,\n    stampedLoginToken: {\n      token: options.resume,\n      when: token.when\n    }\n  };\n};\n\nconst expirePasswordToken = (\n  accounts,\n  oldestValidDate,\n  tokenFilter,\n  userId\n) => {\n  const userFilter = userId ? {_id: userId} : {};\n  const resetRangeOr = {\n    $or: [\n      { \"services.password.reset.when\": { $lt: oldestValidDate } },\n      { \"services.password.reset.when\": { $lt: +oldestValidDate } }\n    ]\n  };\n  const expireFilter = { $and: [tokenFilter, resetRangeOr] };\n\n  accounts.users.update({...userFilter, ...expireFilter}, {\n    $unset: {\n      \"services.password.reset\": \"\"\n    }\n  }, { multi: true });\n};\n\nconst setExpireTokensInterval = accounts => {\n  accounts.expireTokenInterval = Meteor.setInterval(() => {\n    accounts._expireTokens();\n    accounts._expirePasswordResetTokens();\n    accounts._expirePasswordEnrollTokens();\n  }, EXPIRE_TOKENS_INTERVAL_MS);\n};\n\n///\n/// OAuth Encryption Support\n///\n\nconst OAuthEncryption =\n  Package[\"oauth-encryption\"] &&\n  Package[\"oauth-encryption\"].OAuthEncryption;\n\nconst usingOAuthEncryption = () => {\n  return OAuthEncryption && OAuthEncryption.keyIsLoaded();\n};\n\n// OAuth service data is temporarily stored in the pending credentials\n// collection during the oauth authentication process.  Sensitive data\n// such as access tokens are encrypted without the user id because\n// we don't know the user id yet.  We re-encrypt these fields with the\n// user id included when storing the service data permanently in\n// the users collection.\n//\nconst pinEncryptedFieldsToUser = (serviceData, userId) => {\n  Object.keys(serviceData).forEach(key => {\n    let value = serviceData[key];\n    if (OAuthEncryption && OAuthEncryption.isSealed(value))\n      value = OAuthEncryption.seal(OAuthEncryption.open(value), userId);\n    serviceData[key] = value;\n  });\n};\n\n\n// Encrypt unencrypted login service secrets when oauth-encryption is\n// added.\n//\n// XXX For the oauthSecretKey to be available here at startup, the\n// developer must call Accounts.config({oauthSecretKey: ...}) at load\n// time, instead of in a Meteor.startup block, because the startup\n// block in the app code will run after this accounts-base startup\n// block.  Perhaps we need a post-startup callback?\n\nMeteor.startup(() => {\n  if (! usingOAuthEncryption()) {\n    return;\n  }\n\n  const { ServiceConfiguration } = Package['service-configuration'];\n\n  ServiceConfiguration.configurations.find({\n    $and: [{\n      secret: { $exists: true }\n    }, {\n      \"secret.algorithm\": { $exists: false }\n    }]\n  }).forEach(config => {\n    ServiceConfiguration.configurations.update(config._id, {\n      $set: {\n        secret: OAuthEncryption.seal(config.secret)\n      }\n    });\n  });\n});\n\n// XXX see comment on Accounts.createUser in passwords_server about adding a\n// second \"server options\" argument.\nconst defaultCreateUserHook = (options, user) => {\n  if (options.profile)\n    user.profile = options.profile;\n  return user;\n};\n\n// Validate new user's email or Google/Facebook/GitHub account's email\nfunction defaultValidateNewUserHook(user) {\n  const domain = this._options.restrictCreationByEmailDomain;\n  if (!domain) {\n    return true;\n  }\n\n  let emailIsGood = false;\n  if (user.emails && user.emails.length > 0) {\n    emailIsGood = user.emails.reduce(\n      (prev, email) => prev || this._testEmailDomain(email.address), false\n    );\n  } else if (user.services && Object.values(user.services).length > 0) {\n    // Find any email of any service and check it\n    emailIsGood = Object.values(user.services).reduce(\n      (prev, service) => service.email && this._testEmailDomain(service.email),\n      false,\n    );\n  }\n\n  if (emailIsGood) {\n    return true;\n  }\n\n  if (typeof domain === 'string') {\n    throw new Meteor.Error(403, `@${domain} email required`);\n  } else {\n    throw new Meteor.Error(403, \"Email doesn't match the criteria.\");\n  }\n}\n\nconst setupUsersCollection = users => {\n  ///\n  /// RESTRICTING WRITES TO USER OBJECTS\n  ///\n  users.allow({\n    // clients can modify the profile field of their own document, and\n    // nothing else.\n    update: (userId, user, fields, modifier) => {\n      // make sure it is our record\n      if (user._id !== userId) {\n        return false;\n      }\n\n      // user can only modify the 'profile' field. sets to multiple\n      // sub-keys (eg profile.foo and profile.bar) are merged into entry\n      // in the fields list.\n      if (fields.length !== 1 || fields[0] !== 'profile') {\n        return false;\n      }\n\n      return true;\n    },\n    fetch: ['_id'] // we only look at _id.\n  });\n\n  /// DEFAULT INDEXES ON USERS\n  users._ensureIndex('username', {unique: 1, sparse: 1});\n  users._ensureIndex('emails.address', {unique: 1, sparse: 1});\n  users._ensureIndex('services.resume.loginTokens.hashedToken',\n    {unique: 1, sparse: 1});\n  users._ensureIndex('services.resume.loginTokens.token',\n    {unique: 1, sparse: 1});\n  // For taking care of logoutOtherClients calls that crashed before the\n  // tokens were deleted.\n  users._ensureIndex('services.resume.haveLoginTokensToDelete',\n    { sparse: 1 });\n  // For expiring login tokens\n  users._ensureIndex(\"services.resume.loginTokens.when\", { sparse: 1 });\n  // For expiring password tokens\n  users._ensureIndex('services.password.reset.when', { sparse: 1 });\n};\n"]}